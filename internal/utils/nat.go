package utils

import (
	"fmt"
	"github.com/ionos-cloud/docker-machine-driver/internal/pointer"
	"github.com/ionos-cloud/docker-machine-driver/pkg/sdk_utils"
	sdkgo "github.com/ionos-cloud/sdk-go/v6"
	"golang.org/x/exp/maps"
	"strconv"
	"time"
)

func (c *Client) GetNat(datacenterId, natId string) (*sdkgo.NatGateway, error) {
	nat, _, err := c.NATGatewaysApi.DatacentersNatgatewaysFindByNatGatewayId(c.ctx, datacenterId, natId).Execute()
	if err != nil {
		return nil, sdk_utils.ShortenOpenApiErr(err)
	}
	return &nat, nil
}

func (c *Client) CreateNat(datacenterId string, publicIps []string, lansToGateways map[string][]string, subnet string) (*sdkgo.NatGateway, error) {
	var lans []sdkgo.NatGatewayLanProperties
	fmt.Printf("CreateNat(publicIps = %+v, lansMap = %+v, subnet = %s)\n", publicIps, lansToGateways, subnet)

	err := c.createLansIfNotExist(datacenterId, maps.Keys(lansToGateways))
	if err != nil {
		return nil, err
	}
	time.Sleep(10 * time.Second)
	for lanId, gatewayIps := range lansToGateways {
		id, err := strconv.ParseInt(lanId, 10, 32)
		if err != nil {
			return nil, err
		}
		// Unpack the map into NatGatewayLanProperties objects. https://api.ionos.com/docs/cloud/v6/#tag/NAT-Gateways/operation/datacentersNatgatewaysPost
		var ptrGatewayIps *[]string = nil
		if len(gatewayIps) > 1 || gatewayIps[0] != "" {
			// We do this check so that we don't set the GatewayIps property if it's empty. If the property is empty, a gateway IP is generated by the API.
			ptrGatewayIps = &gatewayIps
		}
		lans = append(lans, sdkgo.NatGatewayLanProperties{Id: pointer.To(int32(id)), GatewayIps: ptrGatewayIps})
		fmt.Printf("Created a NatGatewayLanProperties obj with Id: %d, GatewayIps: %+v\n", id, gatewayIps)
	}

	// Configure default NAT Rules
	rules, err := c.MakeNatRules(
		publicIps[0],
		subnet,
		subnet,
		[]sdkgo.TargetPortRange{ // TODO: Investigate if rancher/rke/issues/212 is a complete list
			{
				Start: pointer.To(int32(22)),
				End:   pointer.To(int32(22)),
			},
			{
				Start: pointer.To(int32(53)), // DNS
				End:   pointer.To(int32(53)),
			},
			{
				Start: pointer.To(int32(6443)),
				End:   pointer.To(int32(6443)),
			},
			{
				Start: pointer.To(int32(2376)),
				End:   pointer.To(int32(2376)),
			},
			{
				Start: pointer.To(int32(2379)),
				End:   pointer.To(int32(2380)),
			},
			{
				Start: pointer.To(int32(10250)),
				End:   pointer.To(int32(10252)),
			},
			{
				Start: pointer.To(int32(10255)), // Investigate 10255 if needed
				End:   pointer.To(int32(10256)),
			},
			{
				Start: pointer.To(int32(8472)),
				End:   pointer.To(int32(8472)),
			},
			{
				Start: pointer.To(int32(30000)), // Worker Nodes ports. Maybe worker nodes should have different port config than others?
				End:   pointer.To(int32(32767)),
			},
			//{
			//	Start: pointer.To(int32(21)),
			//	End:   pointer.To(int32(40000)),
			//},
		},
	)

	if err != nil {
		return nil, err
	}

	nat, resp, err := c.NATGatewaysApi.DatacentersNatgatewaysPost(c.ctx, datacenterId).NatGateway(
		sdkgo.NatGateway{
			Properties: &sdkgo.NatGatewayProperties{
				Name:      pointer.To("NAT Docker Machine"),
				PublicIps: &publicIps,
				Lans:      &lans,
			},
			Entities: &sdkgo.NatGatewayEntities{
				Rules:    &sdkgo.NatGatewayRules{Items: rules},
				Flowlogs: nil,
			},
		},
	).Execute()

	if err != nil {
		return nil, err
	}

	fmt.Printf("created nat: %+v\n", nat)

	err = c.waitTillProvisioned(resp.Header.Get("location"))

	return &nat, err
}

// MakeNatRules returns uncreated NatGatewayRules, which are meant to be sent as "entities" for the NAT Post request
func (c *Client) MakeNatRules(publicIp, srcSubnet, targetSubnet string, portRanges []sdkgo.TargetPortRange) (*[]sdkgo.NatGatewayRule, error) {
	properties := &sdkgo.NatGatewayRuleProperties{
		Name: pointer.To("Docker Machine NAT Rule"),
		Type: pointer.To(sdkgo.NatGatewayRuleType("SNAT")),
		//Protocol:     pointer.To(sdkgo.NatGatewayRuleProtocol("ALL")),
		SourceSubnet: &srcSubnet,
		TargetSubnet: &targetSubnet,
		PublicIp:     &publicIp,
	}

	rules := make([]sdkgo.NatGatewayRule, 0)
	for _, portRange := range portRanges {
		properties.TargetPortRange = &portRange
		properties.Protocol = pointer.To(sdkgo.NatGatewayRuleProtocol("TCP"))
		rule := sdkgo.NatGatewayRule{Properties: properties}
		rules = append(rules, rule)
	}

	for _, portRange := range portRanges {
		properties.TargetPortRange = &portRange
		properties.Protocol = pointer.To(sdkgo.NatGatewayRuleProtocol("UDP"))
		rule := sdkgo.NatGatewayRule{Properties: properties}
		rules = append(rules, rule)
	}

	return &rules, nil
}

func (c *Client) createLansIfNotExist(datacenterId string, lanIds []string) error {
	for _, lanid := range lanIds {
		_, resp, err := c.LANsApi.DatacentersLansFindById(c.ctx, datacenterId, lanid).Execute()
		if resp.StatusCode == 404 {
			// Run this before err check, as 404s throws an err.
			fmt.Printf("Creating LAN %s for NAT\n", lanid)
			_, err := c.CreateLan(datacenterId, "Docker Machine LAN (NAT)", false)
			if err != nil {
				return err
			}
			continue // breakpoint
		}
		if err != nil {
			return err
		}
	}
	return nil
}

func (c *Client) RemoveNat(datacenterId, natId string) error {
	_, err := c.NATGatewaysApi.DatacentersNatgatewaysDelete(c.ctx, datacenterId, natId).Execute()
	if err != nil {
		return sdk_utils.ShortenOpenApiErr(err)
	}
	return nil
}
